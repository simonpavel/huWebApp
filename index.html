<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HU Words</title>

  <style>
    :root{
      --bg:#f4f6f8;
      --card:#ffffff;
      --text:#111827;
      --muted:#6b7280;
      --border:#e5e7eb;
      --shadow:0 6px 18px rgba(0,0,0,.06);
      --shadow2:0 2px 8px rgba(0,0,0,.05);

      --primary:#22c55e;
      --primaryText:#ffffff;
      --chip:#eef1f4;

      --dangerBg:#ffefef;
      --dangerText:#b91c1c;

      --star:#f59e0b;
    }

    [data-theme="dark"]{
      --bg:#0b1220;
      --card:#0f1b2d;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --border:#20324b;
      --shadow:0 8px 22px rgba(0,0,0,.35);
      --shadow2:0 4px 14px rgba(0,0,0,.25);

      --chip:#16263f;
      --dangerBg:#3b1620;
      --dangerText:#fecaca;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",system-ui,sans-serif;
    }

    .app{
      max-width:460px;
      margin:0 auto;
      padding:14px 14px 24px;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 2px 14px;
    }

    .title{
      display:flex;
      flex-direction:column;
      gap:2px;
      flex:1 1 auto;
      min-width:0;
    }
    .title h1{
      margin:0;
      font-size:22px;
      line-height:1.1;
      letter-spacing:.2px;
    }
    .subtitle{
      font-size:13px;
      color:var(--muted);
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    .toggles{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:nowrap;
      justify-content:flex-end;
      flex-shrink:0;
    }

    .chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:10px 10px;
      border-radius:12px;
      background:var(--chip);
      border:1px solid var(--border);
      user-select:none;
      font-size:14px;
    }
    .chip input{ width:18px; height:18px; }

    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:16px;
      box-shadow:var(--shadow);
      padding:12px;
      margin-bottom:12px;
    }

    .controls{
      display:grid;
      gap:10px;
    }

    select,input{
      width:100%;
      padding:12px;
      font-size:16px;
      border-radius:12px;
      border:1px solid var(--border);
      background:transparent;
      color:var(--text);
      outline:none;
    }

    .row-top{
      display:grid;
      grid-template-columns:1fr 80px;
      gap:8px;
      align-items:center;
    }

    #wordCount{
      width:80px;
      font-size:14px;
      padding:10px 8px;
    }

    .mode-toggle{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:8px;
    }

    .btn-mode{
      padding:10px;
      font-size:14px;
      border-radius:12px;
      border:1px solid var(--border);
      background:transparent;
      color:var(--text);
      cursor:pointer;
      transition:all 0.2s;
    }

    .btn-mode.active{
      background:var(--primary);
      border-color:var(--primary);
      color:var(--primaryText);
      font-weight:600;
    }

    .row-actions{
      display:grid;
      grid-template-columns:1fr auto;
      gap:8px;
      align-items:center;
    }

    button{
      padding:12px;
      font-size:15px;
      border-radius:12px;
      border:1px solid var(--border);
      background:transparent;
      color:var(--text);
      cursor:pointer;
    }

    button:active{ transform:translateY(1px); }

    .btn-main{
      background:var(--primary);
      border-color:transparent;
      color:var(--primaryText);
      font-weight:700;
    }

    .btn-secondary{
      background:transparent;
    }

    .btn-clear{
      background:var(--dangerBg);
      color:var(--dangerText);
      border-color:transparent;
      font-weight:600;
    }

    .addRow{
      display:grid;
      grid-template-columns:1fr 92px;
      gap:8px;
      align-items:center;
    }

    .progress{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }
    .stats{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .stat{
      font-size:13px;
      color:var(--muted);
      padding:8px 10px;
      border-radius:12px;
      background:transparent;
      border:1px dashed var(--border);
    }
    .progressActions{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .btn-link{
      font-size:13px;
      padding:8px 10px;
      border-radius:12px;
      background:transparent;
      border:1px solid var(--border);
      color:var(--muted);
    }

    .words{
      display:grid;
      gap:10px;
    }

    .wordCard{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:16px;
      box-shadow:var(--shadow2);
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      position:relative;
      overflow:hidden;
    }

    .wordTop{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:10px;
    }

    .wordText{
      font-size:20px;
      line-height:1.2;
      font-weight:650;
      word-break:break-word;
      padding-right:202px;
      min-height:28px;
    }

    .hint{
      font-size:12px;
      color:var(--muted);
    }

    .starBtn, .knowBtn, .repeatBtn, .speakBtn{
      position:absolute;
      top:10px;
      width:42px;
      height:42px;
      border-radius:12px;
      display:flex;
      align-items:center;
      justify-content:center;
      border:1px solid var(--border);
      background:transparent;
      font-size:20px;
      line-height:1;
      cursor:pointer;
    }

    .starBtn{
      right:10px;
    }

    .knowBtn{
      right:58px;
    }

    .repeatBtn{
      right:106px;
    }

    .speakBtn{
      right:154px;
    }

    .starBtn.fav{
      border-color:rgba(245,158,11,.35);
      background:rgba(245,158,11,.12);
    }

    .badge{
      display:inline-flex;
      align-items:center;
      gap:6px;
      font-size:12px;
      color:var(--muted);
    }

    .pill{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      background:transparent;
      font-size:12px;
      color:var(--muted);
      display:inline-flex;
      gap:6px;
      align-items:center;
    }

    .empty{
      text-align:center;
      color:var(--muted);
      padding:28px 10px;
      border:1px dashed var(--border);
      border-radius:16px;
      background:transparent;
    }

    @media (prefers-color-scheme: dark){
      :root:not([data-theme]){
      }
    }
  </style>
</head>

<body>
  <div class="app">

    <div class="topbar">
      <div class="title">
        <h1>HU Words</h1>
        <div class="subtitle" id="countLabel">–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è‚Ä¶</div>
      </div>

      <div class="toggles">
        <label class="chip" title="–¢—ñ–ª—å–∫–∏ –æ–±—Ä–∞–Ω—ñ">
          <input type="checkbox" id="onlyFavToggle" />
          ‚≠ê
        </label>
        <label class="chip" title="–¢–µ–º–Ω–∞ —Ç–µ–º–∞">
          <input type="checkbox" id="themeToggle" />
          üåô
        </label>
      </div>
    </div>

    <section class="card">
      <div class="controls">
        <div class="row-top">
          <select id="wordlistSelect"></select>
          <input type="number" id="wordCount" value="10" min="1" inputmode="numeric" placeholder="Words" />
        </div>

        <div class="mode-toggle">
          <button class="btn-mode" id="btnModeUA" data-mode="ru">Ukrainian</button>
          <button class="btn-mode" id="btnModeHU" data-mode="hu">Hungarian</button>
        </div>

        <div class="row-actions">
          <button class="btn-main" id="btnGenerate">Go</button>
          <button class="btn-clear" id="btnClear">Clear</button>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="addRow">
        <input id="newWord" placeholder="–î–æ—Å—Ç–∞—Ç–Ω—å–æ: el√©g" />
        <button class="btn-secondary" id="btnAdd">Add</button>
      </div>
      <div class="hint" style="margin-top:8px;">
        –ü—ñ–¥–∫–∞–∑–∫–∞: —Ñ–æ—Ä–º–∞—Ç <b>—Å–ª–æ–≤–æ: –ø–µ—Ä–µ–∫–ª–∞–¥</b>. –î–æ–¥–∞–Ω–µ –∑–±–µ—Ä—ñ–≥–∞—î—Ç—å—Å—è –Ω–∞ —Ü—å–æ–º—É –ø—Ä–∏—Å—Ç—Ä–æ—ó.
      </div>
    </section>

    <section class="card">
      <div class="progress">
        <div class="stats">
          <div class="stat" id="statFav">Favorites: 0</div>
          <div class="stat" id="statKnown">Known: 0</div>
          <div class="stat" id="statRepeat">Repeat: 0</div>
        </div>
        <div class="progressActions">
          <button class="btn-link" id="btnResetProgress">Reset all data</button>
        </div>
      </div>
    </section>

    <section class="words" id="output">
      <div class="empty">–ù–∞—Ç–∏—Å–Ω–∏ <b>Go</b>, —â–æ–± –∑–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ —Å–ª–æ–≤–∞ üëÜ</div>
    </section>
  </div>

  <script>
    /***************
     * CONFIG
     ***************/
    const WORDLIST_FILES = [
      "hu_worldList.json",
      "hu_vegetables_fruits.json",
      "hu_clothes.json"
    ];

    /***************
     * STORAGE KEYS
     ***************/
    const STORAGE_LAST = "hw_last_v2";
    const STORAGE_CUSTOM_PREFIX = "hw_custom__";
    const STORAGE_FAVS = "hw_favorites_v2";
    const STORAGE_PROGRESS = "hw_progress_v2";
    const STORAGE_THEME = "hw_theme_v2";
    const STORAGE_ONLYFAV = "hw_onlyfav_v2";
    const STORAGE_LAST_LIST = "hw_last_list_v2";
    const STORAGE_LAST_COUNT = "hw_last_count_v2";
    const STORAGE_LEARNING = "hw_learning_v1";
    const STORAGE_MODE = "hw_mode_v1";

    /***************
     * STATE
     ***************/
    let selectedList = WORDLIST_FILES[0];
    let lastGenerated = [];
    let currentView = [];
    let favorites = new Set();
    let progress = { seen: {}, flipped: {}, totals: { seen: 0, flipped: 0 } };
    let currentMode = "ru"; // "ru" or "hu"

    /***************
     * DOM
     ***************/
    const selectEl = document.getElementById("wordlistSelect");
    const outputEl = document.getElementById("output");
    const countLabel = document.getElementById("countLabel");

    const wordCountEl = document.getElementById("wordCount");
    const onlyFavToggle = document.getElementById("onlyFavToggle");
    const themeToggle = document.getElementById("themeToggle");

    const statFav = document.getElementById("statFav");
    const statKnown = document.getElementById("statKnown");
    const statRepeat = document.getElementById("statRepeat");

    const btnGenerate = document.getElementById("btnGenerate");
    const btnModeUA = document.getElementById("btnModeUA");
    const btnModeHU = document.getElementById("btnModeHU");
    const btnClear = document.getElementById("btnClear");
    const btnAdd = document.getElementById("btnAdd");
    const btnResetProgress = document.getElementById("btnResetProgress");

    /***************
     * HELPERS
     ***************/
    function normalizeText(s) {
      return String(s ?? "").trim();
    }

    function makePairId(entry) {
      const ru = normalizeText(Object.keys(entry)[0]);
      const hu = normalizeText(Object.values(entry)[0]);
      return (ru + "||" + hu).toLowerCase();
    }

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, c => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[c]));
    }

    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function readJSON(key, fallback) {
      try {
        const raw = localStorage.getItem(key);
        return raw ? JSON.parse(raw) : fallback;
      } catch {
        return fallback;
      }
    }

    function writeJSON(key, value) {
      localStorage.setItem(key, JSON.stringify(value));
    }

    function parseEntry(input) {
      const s = normalizeText(input);
      const idx = s.indexOf(":");
      if (idx === -1) return null;
      const left = normalizeText(s.slice(0, idx));
      const right = normalizeText(s.slice(idx + 1));
      if (!left || !right) return null;
      return { [left]: right };
    }

    function haptic() {
      if (navigator.vibrate) navigator.vibrate(10);
    }

    /***************
     * LEARNING STATE
     ***************/
    function getLearningKey(listName, pairId) {
      return `${listName}||${pairId}`;
    }

    function getLearningState(listName, pairId) {
      const learning = readJSON(STORAGE_LEARNING, {});
      const key = getLearningKey(listName, pairId);
      return learning[key] || { known: 0, repeat: 0, lastMark: 0 };
    }

    function setLearningState(listName, pairId, mark) {
      const learning = readJSON(STORAGE_LEARNING, {});
      const key = getLearningKey(listName, pairId);
      const current = learning[key] || { known: 0, repeat: 0, lastMark: 0 };
      const isKnown = current.known > current.repeat;
      const isRepeat = current.repeat > current.known;
      
      if (mark === "known") {
        if (isKnown) {
          // Already "known" - toggle off: remove the mark
          delete learning[key];
        } else {
          // Switch to "known" (from "repeat" or unmarked)
          // This will decrease repeat count and increase known count
          current.known = 1;
          current.repeat = 0;
          current.lastMark = Date.now();
          learning[key] = current;
        }
      } else if (mark === "repeat") {
        if (isRepeat) {
          // Already "repeat" - toggle off: remove the mark
          delete learning[key];
        } else {
          // Switch to "repeat" (from "known" or unmarked)
          // This will decrease known count and increase repeat count
          current.repeat = 1;
          current.known = 0;
          current.lastMark = Date.now();
          learning[key] = current;
        }
      }
      
      writeJSON(STORAGE_LEARNING, learning);
      updateStats();
    }

    function getWordWeight(listName, pairId) {
      const state = getLearningState(listName, pairId);
      if (state.repeat > state.known) return 3;
      if (state.known > state.repeat) return 0.25;
      return 1;
    }

    function weightedRandomSelect(items, n, listName) {
      if (items.length <= n) return items.slice();
      
      const weighted = items.map(item => ({
        item,
        weight: getWordWeight(listName, makePairId(item))
      }));
      
      const selected = [];
      const available = weighted.slice();
      
      for (let i = 0; i < n && available.length > 0; i++) {
        const totalWeight = available.reduce((sum, w) => sum + w.weight, 0);
        let random = Math.random() * totalWeight;
        
        for (let j = 0; j < available.length; j++) {
          random -= available[j].weight;
          if (random <= 0) {
            selected.push(available[j].item);
            available.splice(j, 1);
            break;
          }
        }
      }
      
      return selected;
    }

    function speak(text, lang) {
      if (!('speechSynthesis' in window)) {
        alert("–í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø—ñ–¥—Ç—Ä–∏–º—É—î –æ–∑–≤—É—á–µ–Ω–Ω—è");
        return;
      }
      
      // Cancel any previous speech
      window.speechSynthesis.cancel();
      
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = "hu-HU";
      utterance.rate = 0.9;
      utterance.pitch = 1;
      
      window.speechSynthesis.speak(utterance);
    }

    /***************
     * THEME
     ***************/
    function applyTheme(theme) {
      if (theme === "dark") {
        document.documentElement.setAttribute("data-theme", "dark");
        themeToggle.checked = true;
      } else {
        document.documentElement.removeAttribute("data-theme");
        themeToggle.checked = false;
      }
    }

    /***************
     * LOAD WORDS
     ***************/
    async function loadWords(filename) {
      const res = await fetch(filename, { cache: "no-store" });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(`Cannot load ${filename}: ${res.status} ${res.statusText}. Response: ${text.substring(0, 100)}`);
      }
      
      const contentType = res.headers.get("content-type");
      if (!contentType || !contentType.includes("application/json")) {
        const text = await res.text();
        throw new Error(`Invalid content-type for ${filename}. Got: ${contentType}. Response: ${text.substring(0, 100)}`);
      }
      
      const base = await res.json();

      const customKey = STORAGE_CUSTOM_PREFIX + filename;
      const custom = readJSON(customKey, []);
      return base.concat(custom);
    }

    async function updateCount() {
      try {
        const words = await loadWords(selectedList);
        countLabel.textContent = `${words.length} words ‚Ä¢ ${prettyListName(selectedList)}`;
      } catch (e) {
        countLabel.textContent = `–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è: ${prettyListName(selectedList)}`;
      }
    }

    function prettyListName(filename) {
      const nameMap = {
        "hu_worldList.json": "Szavak",
        "hu_vegetables_fruits.json": "Z√∂lds√©gek √©s gy√ºm√∂lcs√∂k",
        "hu_clothes.json": "Ruh√°zat"
      };
      return nameMap[filename] || filename.replace(/\.json$/i, "").replace(/\.JSON$/i, "");
    }

    /***************
     * FAVORITES
     ***************/
    function loadFavorites() {
      const arr = readJSON(STORAGE_FAVS, []);
      favorites = new Set(Array.isArray(arr) ? arr : []);
    }

    function saveFavorites() {
      writeJSON(STORAGE_FAVS, Array.from(favorites));
      updateStats();
    }

    function isFav(entry) {
      return favorites.has(makePairId(entry));
    }

    function toggleFav(entry) {
      const id = makePairId(entry);
      if (favorites.has(id)) favorites.delete(id);
      else favorites.add(id);
      saveFavorites();
    }

    /***************
     * PROGRESS
     ***************/
    function loadProgress() {
      const p = readJSON(STORAGE_PROGRESS, null);
      if (p && typeof p === "object") progress = p;
      if (!progress.seen) progress.seen = {};
      if (!progress.flipped) progress.flipped = {};
      if (!progress.totals) progress.totals = { seen: 0, flipped: 0 };
    }

    function saveProgress() {
      writeJSON(STORAGE_PROGRESS, progress);
      updateStats();
    }

    function markSeen(entry) {
      const id = makePairId(entry);
      if (!progress.seen[id]) {
        progress.seen[id] = 1;
        progress.totals.seen = (progress.totals.seen || 0) + 1;
        saveProgress();
      }
    }

    function markFlipped(entry) {
      const id = makePairId(entry);
      if (!progress.flipped[id]) {
        progress.flipped[id] = 1;
        progress.totals.flipped = (progress.totals.flipped || 0) + 1;
        saveProgress();
      }
    }

    function resetAllData() {
      // Clear all app-related localStorage keys (except theme preference)
      localStorage.removeItem(STORAGE_LAST);
      localStorage.removeItem(STORAGE_FAVS);
      localStorage.removeItem(STORAGE_PROGRESS);
      // STORAGE_THEME is kept - do not reset night mode preference
      localStorage.removeItem(STORAGE_ONLYFAV);
      localStorage.removeItem(STORAGE_LAST_LIST);
      localStorage.removeItem(STORAGE_LAST_COUNT);
      localStorage.removeItem(STORAGE_LEARNING);
      
      // Clear all custom word lists
      Object.keys(localStorage).forEach(key => {
        if (key.startsWith(STORAGE_CUSTOM_PREFIX)) {
          localStorage.removeItem(key);
        }
      });
      
      // Reset state
      progress = { seen: {}, flipped: {}, totals: { seen: 0, flipped: 0 } };
      favorites = new Set();
      currentView = [];
      lastGenerated = [];
      
      // Clear UI
      outputEl.innerHTML = "";
      renderEmpty("–ù–∞—Ç–∏—Å–Ω–∏ Go, —â–æ–± –∑–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ —Å–ª–æ–≤–∞ üëÜ");
      updateStats();
      
      // Reload page to ensure everything is reset
      location.reload();
    }

    function updateStats() {
      statFav.textContent = `Favorites: ${favorites.size}`;
      
      // Count Known and Repeat
      const learning = readJSON(STORAGE_LEARNING, {});
      let knownCount = 0;
      let repeatCount = 0;
      
      Object.values(learning).forEach(state => {
        if (state.known > state.repeat) knownCount++;
        else if (state.repeat > state.known) repeatCount++;
      });
      
      statKnown.textContent = `Known: ${knownCount}`;
      statRepeat.textContent = `Repeat: ${repeatCount}`;
    }

    /***************
     * RENDER
     ***************/
    function renderEmpty(msg) {
      outputEl.innerHTML = `<div class="empty">${escapeHtml(msg)}</div>`;
    }

    function renderCards(entries, { mode }) {
      currentView = entries.slice();

      if (!entries.length) {
        renderEmpty(onlyFavToggle.checked ? "–ü–æ–∫–∏ –Ω–µ–º–∞—î –æ–±—Ä–∞–Ω–∏—Ö ‚≠ê" : "–ü–æ—Ä–æ–∂–Ω—å–æ. –ù–∞—Ç–∏—Å–Ω–∏ Go, —â–æ–± –∑–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ —Å–ª–æ–≤–∞.");
        return;
      }

      const html = entries.map((entry) => {
        const ru = escapeHtml(Object.keys(entry)[0]);
        const hu = escapeHtml(Object.values(entry)[0]);
        const id = makePairId(entry);
        const favClass = favorites.has(id) ? "fav" : "";

        let frontText = ru;
        let backText = hu;
        let hint = "Tap ‚Üí –ø–µ—Ä–µ–∫–ª–∞–¥";

        if (mode === "hu") {
          frontText = hu;
          backText = ru;
          hint = "Tap ‚Üí –ø–µ—Ä–µ–∫–ª–∞–¥";
        } else if (mode === "both") {
          frontText = `${ru} ‚Äî ${hu}`;
          backText = `${ru} ‚Äî ${hu}`;
          hint = "Tap ‚Üí –ø—Ä–∏—Ö–æ–≤–∞—Ç–∏/–ø–æ–∫–∞–∑–∞—Ç–∏ –Ω–µ –ø–æ—Ç—Ä—ñ–±–Ω–æ";
        }

        // Get learning state for this word
        const learningState = getLearningState(selectedList, id);
        const learningMark = learningState.known > learningState.repeat ? "‚úÖ Know" : 
                           learningState.repeat > learningState.known ? "üîÅ Repeat" : "";
        
        // Show üîä button only when Hungarian is visible
        const showSpeakBtn = mode === "hu" || mode === "both";
        const speakBtnStyle = mode === "ru" ? 'style="display:none;"' : '';

        return `
          <div class="wordCard" data-id="${escapeHtml(id)}" data-ru="${ru}" data-hu="${hu}" data-mode="${escapeHtml(mode)}">
            <button class="starBtn ${favClass}" title="–û–±—Ä–∞–Ω–µ">‚≠ê</button>
            <button class="knowBtn" title="–ó–Ω–∞—é">‚úÖ</button>
            <button class="repeatBtn" title="–ü–æ–≤—Ç–æ—Ä–∏—Ç–∏">üîÅ</button>
            <button class="speakBtn" title="–û–∑–≤—É—á–∏—Ç–∏" ${speakBtnStyle}>üîä</button>

            <div class="wordTop">
              <div>
                <div class="wordText" data-side="front">${frontText}</div>
                <div class="hint">${hint}</div>
              </div>
            </div>

            <div class="badge">
              ${learningMark ? `<span class="pill">${learningMark}</span>` : ''}
            </div>
          </div>
        `;
      }).join("");

      outputEl.innerHTML = html;

      outputEl.querySelectorAll(".wordCard").forEach(card => {
        const id = card.getAttribute("data-id");
        const mode = card.getAttribute("data-mode");

        const entry = { [card.getAttribute("data-ru")]: card.getAttribute("data-hu") };
        markSeen(entry);

        const starBtn = card.querySelector(".starBtn");
        const knowBtn = card.querySelector(".knowBtn");
        const repeatBtn = card.querySelector(".repeatBtn");
        const wordText = card.querySelector(".wordText");
        const speakBtn = card.querySelector(".speakBtn");

        // Handle ‚úÖ Know button
        knowBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          haptic();
          setLearningState(selectedList, id, "known");
          // Update UI to show status
          const badge = card.querySelector(".badge");
          const pills = card.querySelectorAll(".pill");
          const learningState = getLearningState(selectedList, id);
          const learningMark = learningState.known > learningState.repeat ? "‚úÖ Know" : 
                             learningState.repeat > learningState.known ? "üîÅ Repeat" : "";
          
          // Remove all pills first
          pills.forEach(pill => pill.remove());
          
          // Add pill if there's a mark
          if (learningMark) {
            const newPill = document.createElement("span");
            newPill.className = "pill";
            newPill.textContent = learningMark;
            badge.appendChild(newPill);
          }
        });

        // Handle üîÅ Repeat button
        repeatBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          haptic();
          setLearningState(selectedList, id, "repeat");
          // Update UI to show status
          const badge = card.querySelector(".badge");
          const pills = card.querySelectorAll(".pill");
          const learningState = getLearningState(selectedList, id);
          const learningMark = learningState.known > learningState.repeat ? "‚úÖ Know" : 
                             learningState.repeat > learningState.known ? "üîÅ Repeat" : "";
          
          // Remove all pills first
          pills.forEach(pill => pill.remove());
          
          // Add pill if there's a mark
          if (learningMark) {
            const newPill = document.createElement("span");
            newPill.className = "pill";
            newPill.textContent = learningMark;
            badge.appendChild(newPill);
          }
        });

        // Handle üîä button click
        if (speakBtn) {
          speakBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            haptic();
            const hu = card.getAttribute("data-hu");
            const currentText = wordText.textContent;
            
            // Extract Hungarian text based on mode
            let textToSpeak = hu;
            if (mode === "both") {
              // Extract HU part from "UA ‚Äî HU" format
              const parts = currentText.split(" ‚Äî ");
              if (parts.length === 2) {
                textToSpeak = parts[1].trim();
              }
            } else if (mode === "hu") {
              // If HU is on front, speak current text; if flipped, speak HU
              const isFront = wordText.getAttribute("data-side") === "front";
              textToSpeak = isFront ? currentText : hu;
            } else if (mode === "ru") {
              // If flipped to show HU, speak current text; otherwise speak HU
              const isFront = wordText.getAttribute("data-side") === "front";
              textToSpeak = isFront ? hu : currentText;
            }
            
            speak(textToSpeak, "hu-HU");
          });
        }

        starBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          haptic();
          toggleFav(entry);
          starBtn.classList.toggle("fav", isFav(entry));

          if (onlyFavToggle.checked) {
            const filtered = currentView.filter(isFav);
            renderCards(filtered, { mode });
          } else {
            updateStats();
          }
        });

        card.addEventListener("click", () => {
          if (mode === "both") return;

          haptic();
          const ru = card.getAttribute("data-ru");
          const hu = card.getAttribute("data-hu");

          const isFront = wordText.getAttribute("data-side") === "front";
          
          // –ü—Ä–∏ —Ä–µ–∂–∏–º–µ HU: —Ñ—Ä–æ–Ω—Ç = –≤–µ–Ω–≥–µ—Ä—Å–∫–∏–π, –ø–µ—Ä–µ–≤–æ—Ä–æ—Ç = —É–∫—Ä–∞–∏–Ω—Å–∫–∏–π
          // –ü—Ä–∏ —Ä–µ–∂–∏–º–µ RU: —Ñ—Ä–æ–Ω—Ç = —É–∫—Ä–∞–∏–Ω—Å–∫–∏–π, –ø–µ—Ä–µ–≤–æ—Ä–æ—Ç = –≤–µ–Ω–≥–µ—Ä—Å–∫–∏–π
          if (mode === "hu") {
            wordText.textContent = isFront ? ru : hu;
          } else {
          wordText.textContent = isFront ? hu : ru;
          }
          
          wordText.setAttribute("data-side", isFront ? "back" : "front");
          
          // Show/hide üîä button based on whether Hungarian is visible
          if (mode === "ru" && speakBtn) {
            const newIsFront = wordText.getAttribute("data-side") === "front";
            // In "ru" mode: show üîä when flipped (HU visible), hide when on front (UA visible)
            if (newIsFront) {
              speakBtn.style.display = "none";
            } else {
              speakBtn.style.display = "flex";
            }
          }

          if (isFront) markFlipped(entry);
        });
      });

      updateStats();
    }

    /***************
     * ACTIONS
     ***************/
    async function generate(mode) {
      const n = parseInt(wordCountEl.value, 10);
      if (!Number.isFinite(n) || n <= 0) {
        alert("–í–≤–µ–¥—ñ—Ç—å –∫–æ—Ä–µ–∫—Ç–Ω–µ —á–∏—Å–ª–æ");
        return;
      }

      localStorage.setItem(STORAGE_LAST_LIST, selectedList);
      localStorage.setItem(STORAGE_LAST_COUNT, String(n));

      const words = await loadWords(selectedList);
      const picked = weightedRandomSelect(words, n, selectedList);

      lastGenerated = picked;
      writeJSON(STORAGE_LAST, picked);

      const view = onlyFavToggle.checked ? picked.filter(isFav) : picked;
      renderCards(view, { mode });
      await updateCount();
    }

    function translateLast() {
      const saved = readJSON(STORAGE_LAST, []);
      lastGenerated = Array.isArray(saved) ? saved : [];
      const view = onlyFavToggle.checked ? lastGenerated.filter(isFav) : lastGenerated;
      renderCards(view, { mode: "both" });
    }

    function clearOutput() {
      currentView = [];
      outputEl.innerHTML = "";
      renderEmpty("–û—á–∏—â–µ–Ω–æ. –ù–∞—Ç–∏—Å–Ω–∏ Go, —â–æ–± –∑–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ —Å–ª–æ–≤–∞.");
    }

    async function addWord() {
      const val = document.getElementById("newWord").value.trim();
      const entry = parseEntry(val);
      if (!entry) {
        alert("–§–æ—Ä–º–∞—Ç: —Å–ª–æ–≤–æ: –ø–µ—Ä–µ–∫–ª–∞–¥");
        return;
      }

      const key = STORAGE_CUSTOM_PREFIX + selectedList;
      const list = readJSON(key, []);
      list.push(entry);
      writeJSON(key, list);

      document.getElementById("newWord").value = "";
      await updateCount();
      alert("–î–æ–¥–∞–Ω–æ (–∑–±–µ—Ä–µ–∂–µ–Ω–æ –Ω–∞ —Ü—å–æ–º—É –ø—Ä–∏—Å—Ç—Ä–æ—ó).");
    }

    /***************
     * FILTER: ONLY FAVORITES
     ***************/
    function applyOnlyFavFilter() {
      localStorage.setItem(STORAGE_ONLYFAV, onlyFavToggle.checked ? "1" : "0");

      if (currentView.length) {
        const modeGuess = outputEl.querySelector(".wordCard")?.getAttribute("data-mode") || "ru";
        const filtered = onlyFavToggle.checked ? currentView.filter(isFav) : currentView;
        renderCards(filtered, { mode: modeGuess });
      } else {
        renderEmpty(onlyFavToggle.checked ? "–ü–æ–∫–∏ –Ω–µ–º–∞—î –æ–±—Ä–∞–Ω–∏—Ö ‚≠ê" : "–ù–∞—Ç–∏—Å–Ω–∏ Go, —â–æ–± –∑–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ —Å–ª–æ–≤–∞ üëÜ");
      }
    }

    /***************
     * INIT
     ***************/
    function initSelect() {
      selectEl.innerHTML = "";
      WORDLIST_FILES.forEach(f => {
        const opt = document.createElement("option");
        opt.value = f;
        opt.textContent = prettyListName(f);
        selectEl.appendChild(opt);
      });

      const savedList = localStorage.getItem(STORAGE_LAST_LIST);
      if (savedList && WORDLIST_FILES.includes(savedList)) selectedList = savedList;

      selectEl.value = selectedList;

      selectEl.addEventListener("change", async () => {
        selectedList = selectEl.value;
        localStorage.setItem(STORAGE_LAST_LIST, selectedList);
        await updateCount();
        clearOutput();
      });
    }

    function setMode(mode) {
      currentMode = mode;
      localStorage.setItem(STORAGE_MODE, mode);
      
      // Update UI
      if (mode === "ru") {
        btnModeUA.classList.add("active");
        btnModeHU.classList.remove("active");
      } else {
        btnModeHU.classList.add("active");
        btnModeUA.classList.remove("active");
      }
    }

    function initPrefs() {
      const savedTheme = localStorage.getItem(STORAGE_THEME);
      if (savedTheme === "dark") applyTheme("dark");
      else applyTheme("light");

      themeToggle.addEventListener("change", () => {
        const theme = themeToggle.checked ? "dark" : "light";
        localStorage.setItem(STORAGE_THEME, theme);
        applyTheme(theme);
      });

      const onlyFav = localStorage.getItem(STORAGE_ONLYFAV) === "1";
      onlyFavToggle.checked = onlyFav;
      onlyFavToggle.addEventListener("change", applyOnlyFavFilter);

      const savedCount = localStorage.getItem(STORAGE_LAST_COUNT);
      if (savedCount && /^\d+$/.test(savedCount)) wordCountEl.value = savedCount;

      // Restore language mode
      const savedMode = localStorage.getItem(STORAGE_MODE);
      if (savedMode === "hu" || savedMode === "ru") {
        setMode(savedMode);
      } else {
        setMode("ru"); // default
      }
    }

    function bindButtons() {
      btnGenerate.addEventListener("click", () => generate(currentMode));
      btnModeUA.addEventListener("click", () => setMode("ru"));
      btnModeHU.addEventListener("click", () => setMode("hu"));
      btnClear.addEventListener("click", clearOutput);
      btnAdd.addEventListener("click", addWord);
      btnResetProgress.addEventListener("click", () => {
        if (confirm("–°–∫–∏–Ω—É—Ç–∏ –≤—Å—ñ –¥–∞–Ω—ñ? –¶–µ –≤–∏–¥–∞–ª–∏—Ç—å –ø—Ä–æ–≥—Ä–µ—Å, –æ–±—Ä–∞–Ω–µ, –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Ç–∞ –≤—Å—ñ –∑–±–µ—Ä–µ–∂–µ–Ω—ñ —Å–ª–æ–≤–∞.")) {
          resetAllData();
        }
      });

      wordCountEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") generate(currentMode);
      });
    }

    window.addEventListener("load", async () => {
      loadFavorites();
      loadProgress();
      updateStats();
      initPrefs();
      initSelect();
      bindButtons();
      updateStats();
      await updateCount();
    });
  </script>
</body>
</html>
